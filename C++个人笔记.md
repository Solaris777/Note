# C++核心编程

## 1.内存分区模型

**全局区**包含：**全局变量，静态变量，常量**，整个程序执行完之后由系统释放

**栈区**包含：**函数的参数值，局部变量（指针也是局部变量）**，在部分程序执行完后编译器自动释放

**堆区**包含：**指针保存的数据**，通常搭配关键字**new**使用（返回指针），最好由程序员手动释放，否则程序结束时由操作系统回收



关键字**new**

1. **含义**：在堆区开辟一块**新的内存空间**，输出该内存的**指针**
2. **语法**：

```C++
//用指针指向这个新的区域的地址
int* p = new int(3);          //将3赋值给新的区域

//将1赋值给这个区域并用p接收
int p = *new int(1);          //创建一个p=3

//用指针指向这个新的数组的地址，即为数组的首地址
int *q = new int[3];          //创建一个q[3]

//使用完之后记得释放内存
delete p;
```

3. **用处**：使用指针传递时





## 2.引用

### 复习形参与实参

**形参**：通常为函数的参数

**实参**：被赋值的变量

注意：

* 形参只有在函数被调用时才会分配内存，**调用结束后立即释放内存**（栈区的特性），所以形参只有在函数内部有效，不能在函数外部使用
* 如果形参是**引用类型**，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参



### 引用的用法

* 作为**函数参数**：void swap(int& a){}，**定义时要加上&，使用时不用&,直接用a**
* 作为**函数返回值**：可以作为左值（具体见代码）,**不要返回局部变量引用**



### 引用与指针的“区别”

1. 引用即C++包装好的指针操作
2. 引用相当于指针使用时去掉*
3. 引用可以作为左值被赋值，但指针只能作为右值
4. 引用的赋值为变量名，指针的赋值为地址



### 引用与宏定义的区别

1. 宏定义相当于完全取代了变量，引用只是改变了变量名
2. 宏定义不能对两个变量名进行赋值，，相当于对同一个变量进行两次赋值；引用可以再对引用名进行赋值操作，只是修改地址上的值
3. 前者为“**改变**”，后者为“**赋值**”，本质上的不同



## 3.函数高级

### 函数默认参数

形式：void fun(int a,**int b=10,int c=9**){}

* 如果我们自己传入数据，那就用自己的数据，如果没有，那就用默认值
* 如果某个位置已经有了默认参数，那么这个位置往后都必须有默认值
* 如果函数声明有默认参数，函数实现就不能有默认参数



### 函数占位参数

形式：void fun(int a,int){}

* 基本上没什么用



### 函数重载

允许函数名相同的一个功能

函数重载的**满足条件**：

1. 同一个**作用域**下
2. 函数名称相同
3. 函数**参数类型**不同，或者**个数**不同，或者**顺序**不同

注：顺序不同的前提是包含一个以上的参数而且它们的类型不同



## 4.类和对象

### 4.1封装

定义语法：class **类名**{  访问权限**：**   属性    行为}；

使用语法：

1. **类名** 名称;
2. **名称.**属性/行为;

属性：一般为变量，即数据

行为：一般为函数，实现某一功能

#### 访问权限：

1. 公共权限 public         成员 类内可以访问 类外不可以访问
2. 保护权限 protected   成员 类内可以访问 类外不可以访问
3. 私有权限 private        成员 类内可以访问 类外不可以访问

无论是**属性**还是**行为**，它们都具有权限，默认权限为**私有**

### 4.2对象的初始化和清理

#### 1.构造函数与析构函数

* **构造函数语法：**`类名(){}`，构造函数可以有参数，因此可以发生重载，是初始化函数
* **析构函数语法：** `~类名(){}`，析构函数不可以有参数，因此不可以发生重载，可作为**释放堆区内存**函数

```C++
	//析构函数
	~Person()
	{
		//释放堆区内存
		if (m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
		cout << "析构函数调用" << endl;
	}

```



#### 2.构造函数的分类及调用

##### （1）拷贝构造

拷贝构造函数：

C++中拷贝构造函数调用时机通常有三种情况

* 使用一个已经创建完毕的对象来初始化一个新对象（最常用）

* 值传递的方式给函数参数传值

* 以值方式返回局部对象

  

定义拷贝构造函数：

```C++
类名(const 类名& 对象名)
```

* 使用**const**关键字防止拷贝构造函数修改传入的类的属性



###### 深拷贝与浅拷贝

* 浅拷贝：简单的赋值拷贝操作(编译器默认)

```c++
m_height = p.m_height;
```



* 深拷贝：在堆区重新申请空间，进行拷贝操作

```C++
m_height = new int(*p.m_height);
```



注：

1. 栈区的数据先进后出
2. **浅拷贝的问题**：由于共用一块堆区内存，导致堆区内存被重复释放
3. **深拷贝的解决办法**：开辟一块新的内存（new），存储要拷贝的数据



##### （2）三个调用方法

```C++
	//1、括号法
	Person p1;      //无参构造
	Person p2(10);  //有参构造
	Person p3(p2);  //拷贝构造

	//2、显示法
	Person p1;
	Person p2 = Person(10);
	Person p3 = Person(p2);

	//3、隐式转换法
	Person p1;
	Person p2 = 10;
	Person p3 = (p2);
}

```



#### 3.初始化列表

便于初始化类中的属性

**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`



#### 4.类对象作为类成员

即**类嵌套**

执行顺序为：小类构造->大类构造->大类析构->小类析构



#### 5.静态成员

##### （1）静态函数

语法：在函数成员前加上**static**

调用：类名**::**函数名；

##### （2）静态变量

语法：类内：static int m_A;   +  **类外：int Person::m_A=0;**



### 4.3C++对象模型和this指针

#### 1.成员变量和成员函数

* 空对象的类占**一个字节**
* 类内只有非静态成员变量占用内存，其他都不占用



#### 2.this指针

##### （1）解决名称冲突

this**->**age = age ;

直接指向类的属性

##### （2）**非静态成员函数函数**返回对象本身

```C++
	Person& Addage(Person& p)
	{
		this->age += p.age;
		return *this;            //this是指向对象的指针，*this即对象本身
	}
```

* 注意返回值类型为  **类名&**   （引用形式），this指向的一般都是**整个类**
* **真谛：this指的就是所在类本身！！！！！**



#### 3.const修饰成员函数

* 语法：返回值类型 函数名()**const**  {}
* 意义：const修饰的是this指向的值，让这个值不能被修改
* **mutable**关键字：使变量在常函数中也可以被修改



### 4.4友元

#### 1.全局函数作友元

在**类的第一行**写上**friend 函数声明**即可



#### 2.类作友元

```C++
friend class Goodgay;

Building *building;

Goodgay::Goodgay()
{
	building = new Building;
}

```





#### 3.成员函数作友元

```C++
friend void goodGay::visit();

Building *building;

goodGay::goodGay()
{
	building = new Building;
}

```



### 4.5运算符重载

#### 1.加号运算符重载

* 含义：自定义一个名为**operator+**的函数，实现类的对象的相加，并且可以用**+**代替

* 语法：

* 类内函数：

  ```C++
  //运算符重载 可以发生函数重载 
  Person operator+(const Person& p2, int val)  
  {
  	Person temp;
  	temp.m_A = p2.m_A + val;
  	temp.m_B = p2.m_B + val;
  	return temp;
  }
  ```



#### 2.左移运算符重载

* 由于**成员函数**不能达到预期效果，因此只能用**全局函数**
* 语法：

```C++
ostream& operator<<(ostream& cout,Person& p)
{
	cout << "m_A= " << p.m_A << " m_B= " << p.m_B << endl;
	return cout;
}

```

* **ostream**（out stream）为**cout**的数据类型
* 返回引用的原因是**持续输出cout**
* 输入参数在输入时被分割（**遗留问题**）



#### 3.递增运算符重载

```c++
	//前置++
	Person& operator++()
	{
		m_A++;
		return *this;
	}

	//后置++
	Person operator++(int)
	{
		//记录原来的值
		Person p1 = *this;         //这里记录的其实是整个类
		//自增
		m_A++;
		//返回原来的值
		return p1;
	}

```



#### 4.赋值运算符重载

```C++
	Person& operator=(Person& p)
	{
		//清除被赋值对象原有的内存
		if (m_A != NULL)
		{
			delete m_A;
			m_A = NULL;
		}

		//浅拷贝
		//m_A=p.m_A;


		//利用深拷贝
		m_A = new int(*p.m_A);

		return *this;
	}

```

* 注：**返回值为*this,返回类型为Person&**的原因：
  1. 返回的是**整个类**，可以任意调用某个属性
  2. 若返回值为m_A,返回类型为int*则只能返回一个属性
  2. 加上引用即可以作为**左值**使用



#### 5.关系运算符重载

```C++
	bool operator==(Person& p)
	{
		if (this->age == p.age&&this->m_name == p.m_name)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

```



#### 6.函数调用运算符重载

```c++
class Person{
    public:
	void operator()(string word)
	{
		cout << word << endl;
	}
};

class Number{
    void operator()()      //不传入参数
    {
        cout << "1 + 1 = 2" << endl;
    }
};

//重载的()操作符，也称为伪函数
void print()
{
	Person p1;
	p1("hello world");
    Number n1;
    n1();
}

```



### 4.6继承

* 构成：共性+特性
* 好处：减少重复的代码

#### 1.基本语法

```C++
class 子类 : 继承方式 父类
```

子类又称为**派生类**，父类又称为**基类**



#### 2.继承方式

![clip_image002](../Typora图像/clip_image002.png)

* 私有权限都不可访问
* 公有继承没变化
* 保护/私有继承均变为保护/私有权限



#### 3.执行顺序

父构造函数->子构造函数->子析构函数->父析构函数

（类似于类嵌套）



#### 4.protected 和 private 的区别

- private：只能由1.该类中的函数、2.其友元函数访问。不能被任何其他访问，该类的对象也不能访问。
- protected：可以被1.该类中的函数、2.**子类的函数**、以及3.其友元函数访问。但不能被该类的对象访问。



#### 5.继承同名成员处理

* 访问子类同名成员   直接访问即可(s.m_A)
* 访问父类同名成员   需要加作用域（s.**father::**m_A）



#### 6.继承同名静态成员处理方式

1. 同上
2. 通过类名访问
   * Son::m_A;
   * Son::father::m_A;



#### 7.多继承语法

C++中一个类允许继承多个类

语法：

```C++
class 子类 ： 继承方式 父类1，继承方式 父类2...
```



#### 8.虚继承

* 定义：继承前加virtual关键字后，变为虚继承
* 用处：解决**菱形继承**中的数据问题，用在“爷”类上，使之继承下来的数据只有一份



### 4.7多态

多态分为两类

* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名，**地址早绑定**
* 动态多态: 派生类和虚函数实现运行时多态，**地址晚绑定**



##### 动态多态的条件与使用

* 条件

1. 有**继承**关系
2. 子类**重写**父类的虚函数（函数前加**virtual**关键字）



* 使用：

父类的**指针**或者**引用**执行子类对象

```c++
//引用例子
void DoSpeak(Animal & animal)
{
	animal.speak();
}

	//指针例子
AbstractCalculator *abc = new AddCalculator;
abc->m_Num1 = 10;
abc->m_Num2 = 10;
cout << abc->m_Num1 << " + " << abc->m_Num2 << " = " <<abc->getResult() << endl;

delete abc;  //用完了记得销毁
```



##### 纯虚类和抽象类

纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`

当类中有了纯虚函数，这个类也称为==抽象类==

**抽象类特点**：

 * 无法实例化对象
 * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类
 * 调用纯虚函数时使用**指针**类型



##### 虚析构和纯虚析构

​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象

​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

3. 拥有纯虚析构函数的类也属于抽象类

* 用法：在父类析构函数前加上virtual



看一遍组装电脑的示例就大彻大悟了



# C++提高编程

## 1.模板

### 函数类型模板

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。



**语法：** 

```C++
template<typename T>
//函数声明或定义
//或者写成
template<class T>
```

**解释：**

template  ---  声明创建模板

typename  --- 表面其后面的符号是一种数据类型，可以用class代替

T    ---   通用的数据类型，名称可以替换，通常为大写字母



```C
//创建模板
template <typename T>
T Swap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
	return a;
}

void test()
{
	int a = 10;
	int b = 20;
	
    //1、自动类型推导
	a = Swap(a, b);

    //2、显示指定类型
    a = Swap<int>(a,b);
    
	cout << "a= " << a << "b= " << b << endl;
}
```

注意事项：一定要给出模板中通用数据类型的具体类型



#### 普通函数与函数模板的区别

* 普通函数调用可以发生自动类型转换
* 函数模板调用若为**自动类型推导**，**不会发生隐式类型转换**；
* 若为**显式指定类型**，**可以发生隐式类型转换**



#### 模板的具体化

若模板引用的类型为类，必须在后面加上具体化代码指出类型

```C++
template<> bool mycompare(Person &p1,Person &p2)
{

}
```



### 类模板

#### 类模板语法

```C++
//创建类模板
template<class t_name,class t_age>

//使用类模板
Person(t_name name,t_age age)

//对类模板进行定义（一定在构造函数上）
Person<string,int>("xiaoming", 12);
```



#### 类模板与函数模板的区别

* 类模板使用只能用显式指定类型
* 可以在创建类模板的时候定义模板参数类型



#### 类模板中成员函数的创建时机

* 类模板中的成员函数并不是一开始就创建的，在调用时才去创建



#### 类模板做函数参数

```C++
//方式一：指定类型传入
void printfPerson1(Person<string, int> &p)
{
	p.printf();
}

//方式二：参数模板化
template<typename T1,typename T2>
void printfPerson2(Person<T1, T2> &p)
{
	p.printf();
}

//方式三：整个类模板化
template<class T1>
void printfPerson3(T1 &p)
{
	p.printf();
}
```

* 方式一能提高代码可读性，故一般开发中使用的都是方式一



#### 类模板与继承

对于父类中未定义类型的模板，

* 方式一：继承的时候对父类中的模板进行定义（固定）

```C++
class Son1 : public Father<int>
```



* 方式二：在定义子类时使用类模板，随后在子类的使用中定义父类的的模板（灵活）

```C++
template<typename T1,typename T2>
class Son2 :public Father<T2>
{
    T1 name;
};

void test02()
{
	Son2<string, int>s2;
}
```



#### 类模板成员函数类外实现

```C++
//构造函数类外实现
//1.对类模板进行声明
template<typename T1,typename T2>
//2.类外函数需要加上类的作用域（::）
Person<T1, T2>::Person(T1 name, T2 age)

//成员函数类外实现
template<typename T1,typename T2>
void Person<T1, T2>::printf()
```

两个点：

* 类模板声明
* 类的作用域



#### 类模板分文件编写

即将**类模板的定义与实现**另写为.hpp,类内函数的使用只需写在.cpp文件即可

* 注意写.hpp文件时的格式：

```C++
#pragma once
#include <iostream>
using namespace std;
```





## 2.STL

### STL基本概念

STL大体分为六大组件，分别是:**容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器**



1. 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂   （**暂时看作指针**）
4. 仿函数：行为类似函数，可作为算法的某种策略。
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
6. 空间配置器：负责空间的配置与管理。



### 容器算法迭代器初识

容器： `vector`

算法：`for_each`

迭代器：`vector<T>::iterator `

```C++
#include<iostream>
using namespace std;
//包含所用容器的头文件以及全部算法的头文件algorithm
#include<vector>
#include<algorithm>

//遍历算法所需的回调函数
void print(int val)
{
	cout << val << endl;
}

void test()
{
	//实例化对象
	vector<int> v;

	//插入元素
    //调用了容器内的函数
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);

    //第一种遍历方式
	//遍历算法调用，容器起始函数，容器末尾函数，自定义函数名
	for_each(v.begin(), v.end(), print);
    
    //第二种遍历方式
    //使用vector的迭代器iterator,it的类型就是<>l
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << *it << endl;
	}

}

```



